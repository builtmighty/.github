##====== Steps ======##
# 0. Validates deployment configuration and SSH connectivity.
# 1. Checks out the code.
# 2. Sets up deployment keys.
# 3. Checks for uncommitted code.
# 4. Captures uncommitted code, in the form of a patch.
# 5. Applies the patch to a hotfix branch.
# 6. Checks if the hotfix branch was created.
# 7. Updates staging to hotfix branch.
# 8. Deploys code, if no uncommitted code was found.
# 9. Slack notifications.
# 10. Run final job status check.

name: ðŸ”¨ Staging Deployment
env:
  DEFAULT_BRANCH: ${{ github.event.pull_request.base.ref }}

# Controls when the workflow will run
on:
  # Triggers the workflow on push or pull request events but only for the default branch
  pull_request:
    branches:
      - rc/*
    types:
      - closed
  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

# Workflow jobs.
jobs:
  # Validation job - runs first to ensure deployment is configured
  validate-deployment:
    name: Validate Deployment Configuration
    if: ${{ github.event.pull_request.merged == true }}
    runs-on: ubuntu-latest
    
    outputs:
      deployment_enabled: ${{ steps.check_config.outputs.enabled }}
      deployment_type: ${{ steps.check_config.outputs.type }}
    
    steps:
      # Check if deployment is configured for this repository
      - name: Check Deployment Configuration
        id: check_config
        env:
          # SSH secrets
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
          BOT_SIGNING_KEY: ${{ secrets.BOT_SIGNING_KEY }}
          RC_SSH_PORT: ${{ secrets.RC_SSH_PORT }}
          RC_SSH_USER: ${{ secrets.RC_SSH_USER }}
          RC_SSH_HOST: ${{ secrets.RC_SSH_HOST }}
          RC_REMOTE_WEB_ROOT: ${{ secrets.RC_REMOTE_WEB_ROOT }}
          DEPLOY_WORKFLOW_PAT: ${{ secrets.DEPLOY_WORKFLOW_PAT }}
          
          # WP Engine secrets
          WPE_SSH_KEY: ${{ secrets.WPE_SSH_KEY }}
          
          # Slack secrets
          SLACK_CHANNEL_ID: ${{ secrets.SLACK_CHANNEL_ID }}
          SLACK_BOT_API_KEY: ${{ secrets.SLACK_BOT_API_KEY }}
          
          # Variables
          WPENGINE_DEPLOY: ${{ vars.WPENGINE_DEPLOY }}
          STAGING_URL: ${{ vars.STAGING_URL }}
        run: |
          echo "ðŸ” Validating deployment configuration for ${{ github.repository }}"
          echo ""
          
          # Check if WP Engine deployment
          if [ "$WPENGINE_DEPLOY" = "true" ]; then
            echo "ðŸ“¦ Deployment Type: WP Engine"
            
            # Validate WP Engine secrets
            missing_wpe=()
            [ -z "$WPE_SSH_KEY" ] && missing_wpe+=("WPE_SSH_KEY")
            [ -z "${{ vars.WPE_STAGE }}" ] && missing_wpe+=("WPE_STAGE (variable)")
            
            if [ ${#missing_wpe[@]} -gt 0 ]; then
              echo "âŒ Missing WP Engine configuration: ${missing_wpe[*]}"
              echo "enabled=false" >> $GITHUB_OUTPUT
              echo "type=wpengine" >> $GITHUB_OUTPUT
              exit 0
            fi
            
            echo "âœ… WP Engine configuration valid"
            echo "enabled=true" >> $GITHUB_OUTPUT
            echo "type=wpengine" >> $GITHUB_OUTPUT
            
          else
            echo "ðŸ“¦ Deployment Type: SSH"
            
            # Validate SSH secrets
            missing_ssh=()
            [ -z "$SSH_PRIVATE_KEY" ] && missing_ssh+=("SSH_PRIVATE_KEY")
            [ -z "$BOT_SIGNING_KEY" ] && missing_ssh+=("BOT_SIGNING_KEY")
            [ -z "$RC_SSH_PORT" ] && missing_ssh+=("RC_SSH_PORT")
            [ -z "$RC_SSH_USER" ] && missing_ssh+=("RC_SSH_USER")
            [ -z "$RC_SSH_HOST" ] && missing_ssh+=("RC_SSH_HOST")
            [ -z "$RC_REMOTE_WEB_ROOT" ] && missing_ssh+=("RC_REMOTE_WEB_ROOT")
            [ -z "$DEPLOY_WORKFLOW_PAT" ] && missing_ssh+=("DEPLOY_WORKFLOW_PAT")
            
            if [ ${#missing_ssh[@]} -gt 0 ]; then
              echo "âŒ Missing SSH configuration: ${missing_ssh[*]}"
              echo ""
              echo "This repository is not configured for staging deployment."
              echo "To enable deployment, add the required secrets in:"
              echo "Settings â†’ Secrets and variables â†’ Actions"
              echo ""
              echo "enabled=false" >> $GITHUB_OUTPUT
              echo "type=ssh" >> $GITHUB_OUTPUT
              exit 0
            fi
            
            echo "âœ… SSH configuration valid"
            echo "enabled=true" >> $GITHUB_OUTPUT
            echo "type=ssh" >> $GITHUB_OUTPUT
          fi
          
          # Check optional secrets
          if [ -z "$STAGING_URL" ]; then
            echo "âš ï¸  STAGING_URL variable not set (optional)"
          fi
          
          if [ -z "$SLACK_CHANNEL_ID" ] || [ -z "$SLACK_BOT_API_KEY" ]; then
            echo "âš ï¸  Slack notifications not configured (optional)"
          fi
          
          echo ""
          echo "âœ… Deployment configuration validated"
      
      # Test SSH connectivity (only for SSH deployments)
      - name: Test SSH Connectivity
        if: ${{ steps.check_config.outputs.type == 'ssh' && steps.check_config.outputs.enabled == 'true' }}
        env:
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
          RC_SSH_PORT: ${{ secrets.RC_SSH_PORT }}
          RC_SSH_USER: ${{ secrets.RC_SSH_USER }}
          RC_SSH_HOST: ${{ secrets.RC_SSH_HOST }}
        run: |
          echo "ðŸ”Œ Testing SSH connectivity to staging server..."
          
          # Setup SSH key
          mkdir -p ~/.ssh
          echo "$SSH_PRIVATE_KEY" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          
          # Test SSH connection
          if ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no -o ConnectTimeout=10 -p "$RC_SSH_PORT" "$RC_SSH_USER@$RC_SSH_HOST" "echo 'SSH connection successful'" 2>&1; then
            echo "âœ… SSH connection successful"
          else
            echo "âŒ SSH connection failed"
            echo ""
            echo "Cannot connect to staging server. Please verify:"
            echo "  â€¢ SSH_PRIVATE_KEY is correct"
            echo "  â€¢ RC_SSH_HOST is reachable"
            echo "  â€¢ RC_SSH_PORT is correct"
            echo "  â€¢ RC_SSH_USER has proper permissions"
            exit 1
          fi
      
      # Summary
      - name: Validation Summary
        if: always()
        run: |
          echo "## ðŸ” Deployment Configuration" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Repository**: ${{ github.repository }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Deployment Type**: ${{ steps.check_config.outputs.type || 'not configured' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Status**: ${{ steps.check_config.outputs.enabled == 'true' && 'âœ… Enabled' || 'âš ï¸ Not Configured' }}" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ steps.check_config.outputs.enabled }}" != "true" ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "âš ï¸ **Deployment skipped** - Repository not configured for staging deployment" >> $GITHUB_STEP_SUMMARY
          fi

  # Deployment job - only runs if validation passes
  deploy-stage:
    name: Deploy to Staging
    needs: validate-deployment
    # Only run if validation passed and deployment is enabled
    if: ${{ needs.validate-deployment.outputs.deployment_enabled == 'true' }}
    runs-on: [Large-Runner-Ubuntu]
    permissions:
      contents: write
      packages: read
      statuses: write
      pull-requests: write
      issues: write
      deployments: write

    # Steps for the workflow.
    steps:
      ## 1. Checks out the code.
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # Start a deployment.
      - uses: chrnorm/deployment-action@v2
        name: Create GitHub Deployment
        id: github_deployment
        with:
          token: '${{ github.token }}'
          environment-url: ${{ vars.STAGING_URL }}
          environment: staging

      ## 2. Sets up deployment keys.
      # Setup Deployment SSH Key
      - name: Setup Deployment SSH Key
        if: ${{ needs.validate-deployment.outputs.deployment_type == 'ssh' }}
        env:
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          echo "${{ secrets.BOT_SIGNING_KEY }}" > ~/.ssh/bot
          touch ~/.ssh/config
          echo "Host *
          AddKeysToAgent yes
          IgnoreUnknown UseKeychain
          UseKeychain yes
          IdentityFile ~/.ssh/bot" > ~/.ssh/config
          chmod 600 ~/.ssh/id_rsa
          chmod 600 ~/.ssh/bot

      ## 3. Checks for uncommitted code.
      - name: Check for Uncommitted Code on Staging
        if: ${{ needs.validate-deployment.outputs.deployment_type == 'ssh' }}
        continue-on-error: true
        run: |
          ssh -i~/.ssh/id_rsa -o StrictHostKeyChecking=no -p${{ secrets.RC_SSH_PORT }} ${{ secrets.RC_SSH_USER }}@${{ secrets.RC_SSH_HOST }} "cd ${{ secrets.RC_REMOTE_WEB_ROOT }} && git status -s" > ~/.ssh/git-status.txt
          if [[ -s ~/.ssh/git-status.txt ]]; then
            exit 1
          fi
        id: check_uncommitted

      ## 4. Captures uncommitted code, in the form of a patch.
      # Tries to capture via git diff, if that fails, tries git stash show -p.
      - name: Capture Uncommitted Code
        continue-on-error: true
        if: ${{ steps.check_uncommitted.outcome == 'failure' && needs.validate-deployment.outputs.deployment_type == 'ssh' }}
        run: |
          # SSH back in and try git stash show -p for the patch.
          ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no -p ${{ secrets.RC_SSH_PORT }} ${{ secrets.RC_SSH_USER }}@${{ secrets.RC_SSH_HOST }} "
            cd ${{ secrets.RC_REMOTE_WEB_ROOT }}
            # Stash and capture uncommitted code in a patch.
            git stash
            git stash show -p > uncommitted_changes.patch
            git stash apply
            # Get the current commit hash
            git rev-parse HEAD > commit_hash.txt
          "
          # Download the patch file and commit hash.
          scp -i ~/.ssh/id_rsa -P ${{ secrets.RC_SSH_PORT }} ${{ secrets.RC_SSH_USER }}@${{ secrets.RC_SSH_HOST }}:${{ secrets.RC_REMOTE_WEB_ROOT }}/uncommitted_changes.patch .
          scp -i ~/.ssh/id_rsa -P ${{ secrets.RC_SSH_PORT }} ${{ secrets.RC_SSH_USER }}@${{ secrets.RC_SSH_HOST }}:${{ secrets.RC_REMOTE_WEB_ROOT }}/commit_hash.txt .
          # Delete the patch file from remote.
          ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no -p ${{ secrets.RC_SSH_PORT }} ${{ secrets.RC_SSH_USER }}@${{ secrets.RC_SSH_HOST }} "
            cd ${{ secrets.RC_REMOTE_WEB_ROOT }}
            rm -rf uncommitted_changes.patch && rm -rf commit_hash.txt
          "
          if [[ ! -s uncommitted_changes.patch ]]; then
            # SSH back in and get Git version.
            ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no -p ${{ secrets.RC_SSH_PORT }} ${{ secrets.RC_SSH_USER }}@${{ secrets.RC_SSH_HOST }} "
              git --version
            "
            exit 1
          fi
        id: capture_uncommitted

      ## 5. Applies the patch to a hotfix branch.
      - name: Apply Uncommitted Patch and Commit
        continue-on-error: true
        if: ${{ steps.check_uncommitted.outcome == 'failure' && steps.capture_uncommitted.outcome == 'success' && needs.validate-deployment.outputs.deployment_type == 'ssh' }}
        env:
          UNCOMMITTED_BRANCH: hotfix/staging/uncommitted-changes_${{github.run_id}}.${{github.run_attempt}}
          GIT_REPO_URL: https://github.com/${{ github.repository }}
        run: |
          # Capture commit hash.
          COMMIT_HASH=$(cat commit_hash.txt)
          # Checkout current live commit.
          git pull origin $COMMIT_HASH
          git checkout $COMMIT_HASH
          # Apply the patch.
          git apply uncommitted_changes.patch
          # Setup Git signing.
          git config core.filemode false && sudo chown -R $(whoami) . && chown -R $(whoami) .
          git config --global gpg.format ssh
          git config --global user.signingkey ~/.ssh/bot
          git config --global commit.gpgsign true
          git config user.name "builtmightybot"
          git config user.email "bot@builtmighty.com"
          # Clean up.
          rm -rf uncommitted_changes.patch
          # Create uncommitted branch.
          git checkout -b ${{ env.UNCOMMITTED_BRANCH }}
          git push origin ${{ env.UNCOMMITTED_BRANCH }}
          # Commit uncommitted code.
          git add .
          git commit -S -m "ðŸš¨ Captured ALL Uncommitted Code on Staging"
          git push origin ${{ env.UNCOMMITTED_BRANCH }}

      ## 6. Checks if the hotfix branch was created.
      - name: Check Hotfix Branch Exists
        continue-on-error: true
        if: ${{ steps.check_uncommitted.outcome == 'failure' && steps.capture_uncommitted.outcome == 'success' }}
        run: |
          git fetch --all
          git branch -r | grep hotfix/staging/uncommitted-changes_${{github.run_id}}.${{github.run_attempt}}
        id: check_hotfix

      ## 7. Updates staging to hotfix branch.
      - name: Pull Hotfix Branch to Staging
        continue-on-error: true
        if: ${{ steps.check_uncommitted.outcome == 'failure' && steps.capture_uncommitted.outcome == 'success' && steps.check_hotfix.outcome == 'success' }}
        env:
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
          DEPLOY_PAT: ${{ secrets.DEPLOY_WORKFLOW_PAT }}
          GIT_REPO_URL: github.com/${{ github.repository }}
          UNCOMMITTED_BRANCH: hotfix/staging/uncommitted-changes_${{github.run_id}}.${{github.run_attempt}}
        run: |
          ssh -i~/.ssh/id_rsa -o StrictHostKeyChecking=no -p${{ secrets.RC_SSH_PORT }} ${{ secrets.RC_SSH_USER }}@${{ secrets.RC_SSH_HOST }} "
            cd ${{ secrets.RC_REMOTE_WEB_ROOT }}
            git reset --hard
            git clean -fd
            git checkout -b ${{ env.UNCOMMITTED_BRANCH }}
            git pull https://${{ vars.DEPLOY_USER }}:${{ env.DEPLOY_PAT }}@${{ env.GIT_REPO_URL }} ${{ env.UNCOMMITTED_BRANCH }}
          "

      ## 8. Deploys code, if no uncommitted code was found.
      - name: Deploy to Staging
        continue-on-error: true
        if: ${{ steps.check_uncommitted.outcome == 'success' && needs.validate-deployment.outputs.deployment_type == 'ssh' }}
        env:
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
          DEPLOY_PAT: ${{ secrets.DEPLOY_WORKFLOW_PAT }}
          GIT_REPO_URL: github.com/${{ github.repository }}
        run: |
          ssh -i~/.ssh/id_rsa -o StrictHostKeyChecking=no -p${{ secrets.RC_SSH_PORT }} ${{ secrets.RC_SSH_USER }}@${{ secrets.RC_SSH_HOST }} "
            cd ${{ secrets.RC_REMOTE_WEB_ROOT }}
            git checkout ${{ env.DEFAULT_BRANCH }}
            git reset --hard
            git clean -fd
            git pull https://${{ vars.DEPLOY_USER }}:${{ env.DEPLOY_PAT }}@${{ env.GIT_REPO_URL }} ${{ env.DEFAULT_BRANCH }}
          "
        id: deploy_stage

      # WP Engine Deploy.
      - name: Deploy to WP Engine Staging
        continue-on-error: true
        uses: wpengine/github-action-wpe-site-deploy@v3
        if: ${{ needs.validate-deployment.outputs.deployment_type == 'wpengine' }}
        with:
          WPE_SSHG_KEY_PRIVATE: ${{ secrets.WPE_SSH_KEY }} 
          WPE_ENV: ${{ vars.WPE_STAGE }}
        id: deploy_wpe

      # Platform deploy.
      - name: Platform Scripts
        if: ${{ steps.deploy_stage.outcome == 'success' && ( vars.PLATFORM == 'laravel' || vars.PLATFORM == 'wordpress' ) && needs.validate-deployment.outputs.deployment_type == 'ssh' }}
        run: |
          if [ -z "${{ vars.BUILDSCRIPTS }}" ]; then
            echo "Nothing to do here."
          else
            if [ ${{ vars.PLATFORM }} = "laravel" ]; then
              ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no -p ${{ secrets.PROD_SSH_PORT }} ${{ secrets.PROD_SSH_USER }}@${{ secrets.PROD_SSH_HOST }} "
                cd ${{ secrets.PROD_REMOTE_WEB_ROOT }}
                ${{ vars.BUILDSCRIPTS }}
                php artisan optimize:clear
              "
            else
              ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no -p ${{ secrets.PROD_SSH_PORT }} ${{ secrets.PROD_SSH_USER }}@${{ secrets.PROD_SSH_HOST }} "
                cd ${{ secrets.PROD_REMOTE_WEB_ROOT }}
                ${{ vars.BUILDSCRIPTS }}
              "
            fi
          fi
        id: platform_scripts

      # Deploy Success Status.
      - name: Successful GitHub Deployment
        if: ${{ steps.deploy_stage.outcome == 'success' || steps.deploy_wpe.outcome == 'success' }}
        uses: chrnorm/deployment-status@v2
        with:
          token: '${{ github.token }}'
          environment-url: ${{ steps.github_deployment.outputs.environment_url }}
          deployment-id: ${{ steps.github_deployment.outputs.deployment_id }}
          state: 'success'

      # Delete branch that triggered workflow.
      - name: Delete Branch
        if: ${{ steps.check_uncommitted.outcome == 'success' && steps.deploy_stage.outcome == 'success' }}
        run: |
          git push origin --delete ${{ github.head_ref }}

      # Deploy Failure Status.
      - name: Failed GitHub Deployment
        if: ${{ steps.check_uncommitted.outcome == 'failure' || steps.deploy_stage.outcome == 'failure' || steps.deploy_wpe.outcome == 'failure' }}
        uses: chrnorm/deployment-status@v2
        with:
          token: '${{ github.token }}'
          environment-url: ${{ steps.github_deployment.outputs.environment_url }}
          deployment-id: ${{ steps.github_deployment.outputs.deployment_id }}
          state: 'failure'

      ## 9. Slack notifications.
      # Post uncommitted branch to Slack channel.
      - name: Slack Uncommitted Branch Notification
        id: slack_uncommitted
        if: ${{ steps.check_uncommitted.outcome == 'failure' && steps.check_hotfix.outcome == 'success' && secrets.SLACK_BOT_API_KEY != '' }}
        uses: slackapi/slack-github-action@v1.25.0
        with:
          channel-id: ${{ secrets.SLACK_CHANNEL_ID }}
          payload: |
            {
              "text":"ðŸ”» Uncommitted Code on Staging",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*ðŸ”» Uncommitted Code on Staging* | Check out the uncommitted code in this new branch and check if it needs to be merged into the release candidate."
                  },
                  "accessory": {
                    "type": "button",
                    "text": {
                      "type": "plain_text",
                      "text": "ðŸŒ³ Uncommitted Code Branch",
                      "emoji": true
                    },
                    "value": "click_me_123",
                    "url": "${{ env.GIT_REPO_URL }}/tree/${{env.UNCOMMITTED_BRANCH}}",
                    "action_id": "button-action"
                  }
                }
              ]
            }
        env:
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_API_KEY }}
          UNCOMMITTED_BRANCH: hotfix/staging/uncommitted-changes_${{github.run_id}}.${{github.run_attempt}}
          GIT_REPO_URL: https://github.com/${{ github.repository }}

      # Post uncommitted changes to Slack channel.
      - name: Slack Uncommitted Changes Notification
        id: slack_uncommitted_changes_long
        if: ${{ steps.check_uncommitted.outcome == 'failure' && steps.check_hotfix.outcome == 'failure' && secrets.SLACK_BOT_API_KEY != '' }}
        uses: slackapi/slack-github-action@v1.25.0
        with:
          channel-id: ${{ secrets.SLACK_CHANNEL_ID }}
          payload: |
            {
              "text":"ðŸ”» Uncommitted Code on Staging",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*ðŸ”» Uncommitted Code on Staging* | We were unable to grab it though. Find out what to do."
                  },
                  "accessory": {
                    "type": "button",
                    "text": {
                      "type": "plain_text",
                      "text": "ðŸ““ Read Documentation",
                      "emoji": true
                    },
                    "value": "click_me_123",
                    "url": "${{ vars.UNCOMMITTED_FAIL_DOCS }}",
                    "action_id": "button-action"
                  }
                }
              ]
            }
        env:
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_API_KEY }}
          UNCOMMITTED_BRANCH: hotfix/staging/uncommitted-changes_${{github.run_id}}.${{github.run_attempt}}
          GIT_REPO_URL: https://github.com/${{ github.repository }}

      # Slack deployment failure notification.
      - name: Slack Failure Notification
        id: slack_failure_long
        if: ${{ (steps.deploy_stage.outcome == 'failure' || steps.deploy_wpe.outcome == 'failure') && secrets.SLACK_BOT_API_KEY != '' }}
        uses: slackapi/slack-github-action@v1.25.0
        with:
          channel-id: ${{ secrets.SLACK_CHANNEL_ID }}
          payload: |
            {
              "text":"ðŸ˜« Failed Staging Deployment",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*ðŸ˜« Failed Staging Deployment* | Looks like something went wrong with the deployment. The @lead-dev-team will have to take a look."
                  }
                }
              ]
            }
        env:
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_API_KEY }}

      # Slack deployment success notification.
      - name: Slack Success Notification
        id: slack_success_long
        if: ${{ (steps.deploy_stage.outcome == 'success' || steps.deploy_wpe.outcome == 'success') && secrets.SLACK_BOT_API_KEY != '' }}
        uses: slackapi/slack-github-action@v1.25.0
        with:
          channel-id: ${{ secrets.SLACK_CHANNEL_ID }}
          payload: |
            {
              "text":"ðŸŽ‰ Staging Deployment Successful",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*ðŸŽ‰ Staging Deployment Successful* | We had a successful deployment to staging from ${{ github.triggering_actor }}!"
                  },
                  "accessory": {
                    "type": "button",
                    "text": {
                      "type": "plain_text",
                      "text": "ðŸ”— View Staging",
                      "emoji": true
                    },
                    "value": "click_me_123",
                    "url": "${{ vars.STAGING_URL }}",
                    "action_id": "button-action"
                  }
                }
              ]
            }
        env:
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_API_KEY }}

      ## 10. Run final job status check.
      # Check if the job failed or succeeded.
      - name: Final Job Status Check
        if: ${{ steps.check_uncommitted.outcome == 'failure' || steps.deploy_stage.outcome == 'failure' }}
        run: |
          echo "Job failed. Please check the logs for more information."
          exit 1
